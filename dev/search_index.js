var documenterSearchIndex = {"docs":
[{"location":"reference/#Package-Reference","page":"Package Reference","title":"Package Reference","text":"","category":"section"},{"location":"reference/#Abstract-Types","page":"Package Reference","title":"Abstract Types","text":"","category":"section"},{"location":"reference/","page":"Package Reference","title":"Package Reference","text":"The following abstract types are used to derive concrete state and event types.","category":"page"},{"location":"reference/","page":"Package Reference","title":"Package Reference","text":"AbstractHsmEvent\nAbstractHsmState\nHsmStateInfo","category":"page"},{"location":"reference/#HierarchicalStateMachines.AbstractHsmEvent","page":"Package Reference","title":"HierarchicalStateMachines.AbstractHsmEvent","text":"AbstractHsmEvent\n\nAbstract HSM event type.\n\nConcrete events must extend AbstractHsmEvent.\n\n\n\n\n\n","category":"type"},{"location":"reference/#HierarchicalStateMachines.AbstractHsmState","page":"Package Reference","title":"HierarchicalStateMachines.AbstractHsmState","text":"AbstractHsmState\n\nAbstract HSM state type.\n\nConcrete states must extend AbstractHsmState, and either contain an  HsmStateInfo  struct called state_info, or implement the parent_state(),  parent_state!(), active_substate(), and active_substate!() getters and  setters. \n\nPass the parent state to the HsmStateInfo constructor in the concrete state's  constructor if using HsmStateInfo.\n\nExample:\n\nstruct MyState <: AbstractHsmState\n    state_info::HsmStateInfo\n    app_info::MyStatefulApplicationInfo\n\n    MyState(parent_state, app_info) = new(HsmStateInfo(parent_state), app_info)\nend\n\nOtherwise, call parent_state(obj, <parent state>) and  active_substate(obj, nothing) when constructing your concrete state.\n\n\n\n\n\n","category":"type"},{"location":"reference/#HierarchicalStateMachines.HsmStateInfo","page":"Package Reference","title":"HierarchicalStateMachines.HsmStateInfo","text":"HsmStateInfo\n\nState information needed by HSM interfaces that act on AbstractHsmStates.\n\nparent_state::AbstractHsmState – initialized to the parent state of the   concrete state, or nothing if it is the root state machine state.\nactive_substate::AbstractHsmState – initialized to nothing.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Public-Interfaces","page":"Package Reference","title":"Public Interfaces","text":"","category":"section"},{"location":"reference/","page":"Package Reference","title":"Package Reference","text":"The following HierarchicalStateMachines interfaces are used in state machine  implementations.","category":"page"},{"location":"reference/","page":"Package Reference","title":"Package Reference","text":"handle_event!(state_machine::AbstractHsmState, event::AbstractHsmEvent)\ntransition_to_deep_history!(state_machine::AbstractHsmState, state::AbstractHsmState)\ntransition_to_shallow_history!(state_machine::AbstractHsmState, state::AbstractHsmState)\ntransition_to_state!(state_machine::AbstractHsmState, state::AbstractHsmState)","category":"page"},{"location":"reference/#HierarchicalStateMachines.handle_event!-Tuple{AbstractHsmState, AbstractHsmEvent}","page":"Package Reference","title":"HierarchicalStateMachines.handle_event!","text":"handle_event!(state_machine::AbstractHsmState, event::AbstractHsmEvent)\n\nPass event to state_machine for processing.\n\nThis is the public interface to use to pass an event to a state machine for processing.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HierarchicalStateMachines.transition_to_deep_history!-Tuple{AbstractHsmState, AbstractHsmState}","page":"Package Reference","title":"HierarchicalStateMachines.transition_to_deep_history!","text":"transition_to_deep_history!(state_machine::AbstractHsmState, state::AbstractHsmState)\n\nChange the active state of state_machine, following the active state of state as far as it goes.\n\nThis is the interface to use in a state's event handler (on_event!()) to  transition to the deep history of a state.\n\nstruct Machine <: AbstractHsmState ; end\nstruct MyState <: AbstractHsmState ; end\nstruct MyOtherState <: AbstractHsmState ; end\nstruct MySubState1 <: AbstractHsmState ; end\nstruct MySubState2 <: AbstractHsmEvent ; end\nstruct MySubSubState1 <: AbstractHsmEvent ; end\nstruct MySubSubState2 <: AbstractHsmEvent ; end\nstruct MyEvent <: AbstractHsmEvent ; end\n\nmachine = Machine(nothing)\nmy_state = MyState(machine)\nmy_other_state = MyOtherState(machine)\nmy_sub_state_1 = MySubState1(my_other_state)\nmy_sub_state_2 = MySubState2(my_other_state)\nmy_sub_sub-state_1 = MySubSubState1(my_sub_state_1)\nmy_sub_sub-state_2 = MySubSubState2(my_sub_state_1)\n\nfunction on_event!(state::MyState, event::MyEvent)\n    # Will transition last active state in my_other_state -- my_other_state,\n    # my_sub_state_1, my_sub-state_2, my_sub_sub_state_1, or my_sub_sub_state_2.\n    transition_to_shallow_history!(machine, my_other_state)\nend\n\nThis interface corresponds to an arrow to a deep history marker in a state.\n\n@startuml\nstate Machine {\n    state MyState\n    state MyOtherState {\n        state MySubState1 {\n            state MySubSubState1\n            state MySubSubState2\n        }\n        state MySubState2\n    }\n\n    MyState --> MyOtherState[H*]\n}\n@enduml\n\n\n\n\n\n","category":"method"},{"location":"reference/#HierarchicalStateMachines.transition_to_shallow_history!-Tuple{AbstractHsmState, AbstractHsmState}","page":"Package Reference","title":"HierarchicalStateMachines.transition_to_shallow_history!","text":"transition_to_shallow_history!(state_machine::AbstractHsmState, state::AbstractHsmState)\n\nChange the active state of state_machine, following the active state of state as much as one layer.\n\nThis is the interface to use in a state's event handler (on_event!()) to  transition to the history of a state.\n\nstruct Machine <: AbstractHsmState ; end\nstruct MyState <: AbstractHsmState ; end\nstruct MyOtherState <: AbstractHsmState ; end\nstruct MySubState1 <: AbstractHsmState ; end\nstruct MySubState2 <: AbstractHsmEvent ; end\nstruct MyEvent <: AbstractHsmEvent ; end\n\nmachine = Machine(nothing)\nmy_state = MyState(machine)\nmy_other_state = MyOtherState(machine)\nmy_sub_state_1 = MySubState1(my_other_state)\nmy_sub_state_2 = MySubState2(my_other_state)\n\nfunction on_event!(state::MyState, event::MyEvent)\n    # Will transition to last active state in my_other_state -- my_other_state,\n    # my_sub_state_1, or my_sub_state_2.\n    transition_to_shallow_history!(machine, my_other_state)\nend\n\nThis interface corresponds to an arrow to a history marker in a state.\n\n@startuml\nstate Machine {\n    state MyState\n    state MyOtherState {\n        state MySubState1\n        state MySubState2\n    }\n\n    MyState --> MyOtherState[H]\n}\n@enduml\n\n\n\n\n\n","category":"method"},{"location":"reference/#HierarchicalStateMachines.transition_to_state!-Tuple{AbstractHsmState, AbstractHsmState}","page":"Package Reference","title":"HierarchicalStateMachines.transition_to_state!","text":"transition_to_state!(machine::AbstractHsmState, state::AbstractHsmState)\n\nChange the active state of state_machine to state.\n\nThis is the interface to use in a state's event handler (on_event!(),  on_initialize()) to transition states.\n\nstruct Machine <: AbstractHsmState ; end\nstruct MyState <: AbstractHsmState ; end\nstruct MyOtherState <: AbstractHsmState ; end\nstruct MyEvent <: AbstractHsmEvent ; end\n\nmachine = Machine(nothing)\nmy_state = MyState(machine)\nmy_other_state = MyOtherState(machine)\n\nfunction on_event!(state::MyState, event::MyEvent)\n    # Active state becomes my_other_state.\n    transition_to_state!(machine, my_other_state)\nend\n\nThis interface corresponds to arrows from one state to another in a UML state chart.\n\n@startuml\nstate Machine {\n    state MyState\n    state MyOtherState\n\n    MyState --> MyOtherState\n}\n@enduml\n\n\n\n\n\n","category":"method"},{"location":"reference/#Extendable-Interfaces","page":"Package Reference","title":"Extendable Interfaces","text":"","category":"section"},{"location":"reference/","page":"Package Reference","title":"Package Reference","text":"The following interfaces are extended to implement event handlers for specific states and events.","category":"page"},{"location":"reference/","page":"Package Reference","title":"Package Reference","text":"on_entry!(state::AbstractHsmState)\non_event!(state::AbstractHsmState, event::AbstractHsmEvent)\non_exit!(state::AbstractHsmState)\non_initialize!(state::AbstractHsmState)","category":"page"},{"location":"reference/#HierarchicalStateMachines.on_entry!-Tuple{AbstractHsmState}","page":"Package Reference","title":"HierarchicalStateMachines.on_entry!","text":"on_entry!(state::AbstractHsmState)\n\nGlobal state entry handler.\n\nCreate entry handlers for your derived states when you want that state to  execute something whenever it is entered. This includes transitions to itself.\n\nstruct MyState <: AbstractHsmState ; end\n\nfunction on_entry!(state::MyState)\n    # do something.\nend\n\nState-specific instances of on_entry!() correspond to \"on entry / action\" labels in state blocks in UML state charts.\n\n@startuml\nstate Machine {\n    state MyState\n    MyState : on entry / do something\n}\n@enduml\n\nThe global state entry handler is the default behavior of a state. It does not do anything.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HierarchicalStateMachines.on_event!-Tuple{AbstractHsmState, AbstractHsmEvent}","page":"Package Reference","title":"HierarchicalStateMachines.on_event!","text":"on_event!(state::AbstractHsmState, event::AbstractHsmEvent)\n\nGlobal event handler.\n\nCreate event handlers for your derived states and events to handle those specific events in those states.\n\nstruct MyState <: AbstractHsmState ; end\nstruct MyEvent <: AbstractHsmEvent ; end\n\nfunction on_event!(state::MyState, event::MyEvent)\n    # process event.\n    return true\nend\n\nState-specific event handlers are expected to return true when they handle an event, unless they specifically want their parent state to process the event as well.\n\nState-specific instances of on_event!() correspond to \"event / action\" labels in state blocks or on state transitions in UML state charts.\n\n@startuml\nstate ExampleMachine {\n    state MyState \n    state MyOtherState\n\n    MyState --> MyOtherState : MyEvent / do something\n    MyOtherState : MyEvent / do something\n}\n@enduml\n\nThe global event handler is called as a last resort, and is expected to return  false to generate an HsmUnhandledEventError.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HierarchicalStateMachines.on_exit!-Tuple{AbstractHsmState}","page":"Package Reference","title":"HierarchicalStateMachines.on_exit!","text":"on_entry!(state::AbstractHsmState)\n\nGlobal state exit handler.\n\nCreate exit handlers for your derived states when you want that state to execute something whenever it is exited. This includes transitions to itself.\n\nstruct MyState <: AbstractHsmState ; end\n\nfunction on_exit!(state::MyState)\n    # do something.\nend\n\nState-specific instances of on_exit!() correspond to \"on exit / action\" labels in state blocks in UML state charts.\n\n@startuml\nstate Machine {\n    state MyState\n    MyState : on exit / do something\n}\n@enduml\n\nThe global state exit handler is the default behavior of a state. It does not do  anything.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HierarchicalStateMachines.on_initialize!-Tuple{AbstractHsmState}","page":"Package Reference","title":"HierarchicalStateMachines.on_initialize!","text":"on_initialize!(state::AbstractHsmState)\n\nGlobal state initializer.\n\nCreate initializers for states that must be initialized upon entry. Generally, this is used when a state has sub-states, where one must be transitioned to when the state is entered. For example, the root state machine.\n\nstruct Machine <: AbstractHsmState ; end\nstruct MyState <: AbstractHsmState ; end\n\nmachine = Machine(nothing)\nmy_state = MyState(machine)\n\nfunction on_initialize!(state::Machine)\n    transition_to_state!(my_state)\nend\n\nState-specific instances of on_initialize!() correspond to the starting point  trasitions in UML state charts.\n\n@startuml\nstate Machine {\n    state MyState\n\n    [*] --> MyState\n}\n@enduml\n\nThe global state initializer is the default behavior of a state. It does not do  anything.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Extendable-Getters-and-Setters","page":"Package Reference","title":"Extendable Getters and Setters","text":"","category":"section"},{"location":"reference/","page":"Package Reference","title":"Package Reference","text":"The following getters and setters are extended to implement the required parent and active state requirements for concrete implementations of  AbstractHsmState. Extending the getters and setters is only necessary if the concrete implementation does not have a state_info::HsmStateInfo member.","category":"page"},{"location":"reference/","page":"Package Reference","title":"Package Reference","text":"active_substate(obj::AbstractHsmState)\nactive_substate!(obj::AbstractHsmState, value::Union{AbstractHsmState, Nothing})\nparent_state(obj::AbstractHsmState)\nparent_state!(obj::AbstractHsmState, value::Union{AbstractHsmState, Nothing})","category":"page"},{"location":"reference/#HierarchicalStateMachines.active_substate-Tuple{AbstractHsmState}","page":"Package Reference","title":"HierarchicalStateMachines.active_substate","text":"active_substate(obj::AbstracHsmState)\n\nactive_substate getter.\n\nExtend this for your concrete class if your concrete struct does not include  state_info::HsmStateInfo.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HierarchicalStateMachines.active_substate!-Tuple{AbstractHsmState, Union{Nothing, AbstractHsmState}}","page":"Package Reference","title":"HierarchicalStateMachines.active_substate!","text":"active_substate!(obj::AbstractHsmState, value::Union{AbstractHsmState, Nothing})\n\nactive_substate setter.\n\nExtend this for your concrete class if your concrete struct does not include  state_info::HsmStateInfo.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HierarchicalStateMachines.parent_state-Tuple{AbstractHsmState}","page":"Package Reference","title":"HierarchicalStateMachines.parent_state","text":"parent_state(obj::AbstractHsmState)\n\nparent_state getter. \n\nExtend this for your concrete class if your concrete struct does not include  state_info::HsmStateInfo.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HierarchicalStateMachines.parent_state!-Tuple{AbstractHsmState, Union{Nothing, AbstractHsmState}}","page":"Package Reference","title":"HierarchicalStateMachines.parent_state!","text":"parent_state!(obj::AbstractHsmState, value::Union{AbstractHsmState, Nothing})\n\nparent_state setter.\n\nExtend this for your concrete class if your concrete struct does not include  state_info::HsmStateInfo.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Exceptions","page":"Package Reference","title":"Exceptions","text":"","category":"section"},{"location":"reference/","page":"Package Reference","title":"Package Reference","text":"The following exceptions are defined and used by HierarchicalStateMachines.","category":"page"},{"location":"reference/","page":"Package Reference","title":"Package Reference","text":"HsmUnhandledEventError\nHsmStateTransitionError","category":"page"},{"location":"reference/#HierarchicalStateMachines.HsmUnhandledEventError","page":"Package Reference","title":"HierarchicalStateMachines.HsmUnhandledEventError","text":"Unhandled event exception.\n\nThis gets thrown if an event is not handled by the state machine when handle_event!() is called. This usually means the root state machine state does not have an event handler for the event type, or is not returning true.\n\n\n\n\n\n","category":"type"},{"location":"reference/#HierarchicalStateMachines.HsmStateTransitionError","page":"Package Reference","title":"HierarchicalStateMachines.HsmStateTransitionError","text":"State transition failed exception.\n\nThis gets thrown if the destination state is not a part of the state machine when transition_to_state!() is called.\n\n\n\n\n\n","category":"type"},{"location":"#HierarchicalStateMachines.jl","page":"Home","title":"HierarchicalStateMachines.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Hierarchical state machine library based on Unified Modeling Language state machines (also called state charts).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Hierarchical state machines allow for the use of sub-states within states. This can reduce boilerplate actions in similar states by encapsulating those states in a parent state, and moving the boilerplate action to the parent state.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You can obtain HierarchicalStateMachines using Julia's Package Manager REPL.","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add HierarchicalStateMachine","category":"page"},{"location":"#Use","page":"Home","title":"Use","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The general procedure for implementing a state machine using  HierarchicalStateMachines is to create a (possibly mutable) struct derived  from AbstractHsmState for every state in the state machine, as well as the  state machine itself. Each derived struct must contain, at a minimum,  state_info::HierarchicalStateMachines.HsmStateInfo. Generally speaking, there  will also be a reference to a container holding process data to be acted upon.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For every user-defined event handled by the state machine, create a struct  derived from AbstractHsmEvent. There are no required fields for the struct  derived from AbstractHsmEvent.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Instantiate one instance of each state. Top-level states pass the state machine instance as the parent_state argument to its contained state_info.  Sub-states pass their parent state instance as the parent_state. The root  state machine state passes nothing as the parent state.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For example, to create a state machine called MyStateMachine that contains two states FooState and BarState, you would define three concrete  derivations of AbstractHsmState containing a minimum of a state_info field. Their constructors would take a parent_state argument that got passed to the HsmStateInfo constructor for state_info.","category":"page"},{"location":"","page":"Home","title":"Home","text":"struct MyStateMachine <: AbstractHsmState\n    state_info::HsmStateInfo\n\n    MyStateMachine(parent) = new(HsmStateInfo(parent))\nend\n\nstruct FooState <: AbstractHsmState\n    state_info:HsmStateInfo\n\n    FooState(parent) = new(HsmStateInfo(parent))\nend\n\nstruct BarState <: AbstractHsmState\n    state_info::HsmStateInfo\n\n    BarState(parent) = new(HsmStateInfo(parent))\nend\n\nmy_state_machine = MyStateMachine(nothing)\nfoo_state = FooState(my_state_machine)\nbar_state = BarState(my_state_machine)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Extend on_event!() to handle specific events in specific states. Similarly,  extend on_entry!(), on_exit!(), and on_initialize!() as necessary. Be sure  event handlers for the root state machine state handle all expected events, and  return true in each on_event!() extension.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Use transition_to_state!(), transition_to_shallow_history!(), and transition_to_deep_history!() in your event handlers to effect state transitions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Finally, in your event loop, pass events to the state machine by calling handle_event!().","category":"page"},{"location":"","page":"Home","title":"Home","text":"See test_thermometer.jl  for a concrete example, minus the event loop.","category":"page"}]
}
